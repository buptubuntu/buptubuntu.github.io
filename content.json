[{"title":"Spring Best Practice","date":"2017-01-02T04:19:26.000Z","path":"2017/01/02/Spring-Best-Practice/","text":"Spring 最佳实践编程语言或者是框架的实现往往允许我们通过多种方式去解决我们现实业务中遇到的问题，往往对于同一个问题我们不同的人会使用不同的方法去解决问题，但是从前辈的经验或者说从系统的可扩展性、后续维护成本的角度来说，一些沉淀下来的方式相比于其他同样可以解决现在业务问题的方式才是最佳的实践方式。 INTERFACES AND SPRING1If,after reading the last couple of paragraphs,you feel that I have a strong bias toward hiding the persistence layer hebind interfaces,then I&apos;m happy I was able to get that point acrss. I believe that interfaces are key to writing loosely coupled code and that they should be used at all layers of an application, not just at the data-access layer.That said, it&apos;s also important to note that though Spring encourages the use of interfaces, Spring dosen&apos;t require them--you&apos;re welcome to use Spring to write a bean(repository or otherwise) directly into a property of another bean without an interface between them. 上面的话摘自Spring in Action, Spring框架允许我们在IOC时注入接口（框架自动匹配实现了接口的具体类的bean）或者直接注入具体类型的bean, 不可否认, 我们可以在具体的实现时可以不用定义接口，直接定义具体的实现类来达到我们的目的，但是这样的系统内部往往耦合性比较高，不利于后续的扩展和维护，所以Spring鼓励框架的使用者通过定义接口来约定行为集合，然后通过具体类实现接口，已达到松耦合的目的。 SPRING’S PERSISTENCE PLATFORM-AGNOSTIC EXCEPTIONS123456789Spring JDBC provides hierarchy of data-access exceptions that solve both problems. In constrast to JDBC, Spring provides several data-access exceptions, each descriptive of the problem for which they&apos;re thrown.Even though Spring&apos;s exception hierarchy is far richer than JDBC&apos;s simple SQL-Exception it isn&apos;t associated with any particular persistence solution. This means you can count on Spring to throw a consistent set of exceptions, regardlesss of which persistence provider you choose. This helps to keep your persistence choice confined to the data-access layer.To take advantage of Spring&apos;s data-access esceptions, you must use one of Spring&apos;s supported data-access templates.(Design pattern: template method pattern)Spring separates the fixed and variable parts of the data-access process into two distinct classes: templates and callbacks. Templates manage the fixed part of the process, whereas your custom data-access code is handled in callbacks.JDBC is the most basic way to work with ralational data in Java. But as defined in the specification,JDBC can be somewhat unwieldy. Spring takes much of the pain out of working with JDBC, eliminating boilerpalte code and simplifying JDBC exception handling, leaving you little more to deal with than writing the SQL that should be performed.","link":"","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://buptubuntu.github.io/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"https://buptubuntu.github.io/tags/Java/"},{"name":"Best Practice","slug":"Best-Practice","permalink":"https://buptubuntu.github.io/tags/Best-Practice/"}]},{"title":"Spring MVC Exception Handling","date":"2016-12-29T10:35:57.000Z","path":"2016/12/29/Spring-MVC-Exception-Handling/","text":"在Spring MVC中可以从三个角度对异常进行处理： 对特定类型的异常进行处理 对特定类型的Controller类进行异常处理 全局异常处理 对特定类型的异常进行处理对于特定类型的异常，我们可以通过给异常类添加ResponseStatus注解，在Controller类抛出此类异常时Spring MVC框架会自动将指定的相应码写入到请求的响应中。 比如如果有一个异常表示没有查询到订单： 1234@ResponseStatus(value=HttpStatus.NOT_FOUND, reason=\"No such Order\") // 404 public class OrderNotFoundException extends RuntimeException &#123; // ... &#125; 在某个Controller中抛出了该异常： 123456789@RequestMapping(value=\"/orders/&#123;id&#125;\", method=GET) public String showOrder(@PathVariable(\"id\") long id, Model model) &#123; Order order = orderRepository.findOrderById(id); if (order == null) throw new OrderNotFoundException(id); model.addAttribute(order); return \"orderDetail\"; &#125; 那么当请求的订单ID不存的时候，请求的响应验证码就是404 单个Controller类中的异常处理在单个Controller类中，我们可以单独定义一个方法，并使用ExceptionHandler注解标注该方法，那么此Contrller类中如果有请求抛出特定异常时将由改方法来处理。代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940@Controllerpublic class ExceptionHandlingController &#123; // @RequestHandler methods ... // Exception handling methods // Convert a predefined exception to an HTTP Status code @ResponseStatus(value=HttpStatus.CONFLICT, reason=\"Data integrity violation\") // 409 @ExceptionHandler(DataIntegrityViolationException.class) public void conflict() &#123; // Nothing to do &#125; // Specify name of a specific view that will be used to display the error: @ExceptionHandler(&#123;SQLException.class,DataAccessException.class&#125;) public String databaseError() &#123; // Nothing to do. Returns the logical view name of an error page, passed // to the view-resolver(s) in usual way. // Note that the exception is NOT available to this view (it is not added // to the model) but see \"Extending ExceptionHandlerExceptionResolver\" // below. return \"databaseError\"; &#125; // Total control - setup a model and return the view name yourself. Or // consider subclassing ExceptionHandlerExceptionResolver (see below). @ExceptionHandler(Exception.class) public ModelAndView handleError(HttpServletRequest req, Exception ex) &#123; logger.error(\"Request: \" + req.getRequestURL() + \" raised \" + ex); ModelAndView mav = new ModelAndView(); mav.addObject(\"exception\", ex); mav.addObject(\"url\", req.getRequestURL()); mav.setViewName(\"error\"); return mav; &#125;&#125; 全局异常处理在很多情况下，我们可能想要对所有Controller抛出的异常做统一的处理，在这种情况下，我们可以充分利用Spring提供的切面功能，在Spring MVC中我们可以通过简单的ControllerAdvice注解达到目的。代码示例如下：12345678@ControllerAdviceclass GlobalControllerExceptionHandler &#123; @ResponseStatus(HttpStatus.CONFLICT) // 409 @ExceptionHandler(DataIntegrityViolationException.class) public void handleConflict() &#123; // Nothing to do &#125;&#125; 通过上面的代码，所有Controller抛出的DataIntegrityViolationException异常都讲集中进行处理。","link":"","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"https://buptubuntu.github.io/tags/Spring-MVC/"},{"name":"Exception Handling","slug":"Exception-Handling","permalink":"https://buptubuntu.github.io/tags/Exception-Handling/"}]}]