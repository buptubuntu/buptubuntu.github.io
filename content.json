[{"title":"Spring MVC Could not parse header json","date":"2017-04-01T09:10:46.000Z","path":"2017/04/01/Spring-MVC-Could-not-parse-header-json/","text":"What Happened When Configure ContentNegotiationManager基于Spring Boot的后台rest接口工程，通过使用EnableWebMvc注解可以开启Spring MVC支持，并且通过扩展WebMvcConfigurer或其抽象子类WebMvcConfigurerAdapter，覆写其configureContentNegotiation方法可以配置Spring MVC框架在确定请求对应媒体类型的行为，而Spring MVC框架在判断一个请求对应的媒体类型时，是通过注册一个ContentNegotiationManager类型的Bean，所有的判断行为逻辑都在这个类里面。而这个类其实是将实际的业务逻辑代理给了它的成员变量strategies。源代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/* * Copyright 2002-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.web.accept;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.LinkedHashSet;import java.util.List;import java.util.Set;import org.springframework.http.MediaType;import org.springframework.util.Assert;import org.springframework.web.HttpMediaTypeNotAcceptableException;import org.springframework.web.context.request.NativeWebRequest;/** * Central class to determine requested &#123;@linkplain MediaType media types&#125; * for a request. This is done by delegating to a list of configured * &#123;@code ContentNegotiationStrategy&#125; instances. * * &lt;p&gt;Also provides methods to look up file extensions for a media type. * This is done by delegating to the list of configured * &#123;@code MediaTypeFileExtensionResolver&#125; instances. * * @author Rossen Stoyanchev * @since 3.2 */public class ContentNegotiationManager implements ContentNegotiationStrategy, MediaTypeFileExtensionResolver &#123; private static final List&lt;MediaType&gt; MEDIA_TYPE_ALL = Collections.&lt;MediaType&gt;singletonList(MediaType.ALL); private final List&lt;ContentNegotiationStrategy&gt; strategies = new ArrayList&lt;ContentNegotiationStrategy&gt;(); private final Set&lt;MediaTypeFileExtensionResolver&gt; resolvers = new LinkedHashSet&lt;MediaTypeFileExtensionResolver&gt;(); /** * Create an instance with the given list of * &#123;@code ContentNegotiationStrategy&#125; strategies each of which may also be * an instance of &#123;@code MediaTypeFileExtensionResolver&#125;. * @param strategies the strategies to use */ public ContentNegotiationManager(ContentNegotiationStrategy... strategies) &#123; this(Arrays.asList(strategies)); &#125; /** * A collection-based alternative to * &#123;@link #ContentNegotiationManager(ContentNegotiationStrategy...)&#125;. * @param strategies the strategies to use */ public ContentNegotiationManager(Collection&lt;ContentNegotiationStrategy&gt; strategies) &#123; Assert.notEmpty(strategies, \"At least one ContentNegotiationStrategy is expected\"); this.strategies.addAll(strategies); for (ContentNegotiationStrategy strategy : this.strategies) &#123; if (strategy instanceof MediaTypeFileExtensionResolver) &#123; this.resolvers.add((MediaTypeFileExtensionResolver) strategy); &#125; &#125; &#125; /** * Create a default instance with a &#123;@link HeaderContentNegotiationStrategy&#125;. */ public ContentNegotiationManager() &#123; this(new HeaderContentNegotiationStrategy()); &#125; /** * Return the configured content negotiation strategies. * @since 3.2.16 */ public List&lt;ContentNegotiationStrategy&gt; getStrategies() &#123; return this.strategies; &#125; /** * Find a &#123;@code ContentNegotiationStrategy&#125; of the given type. * @param strategyType the strategy type * @return the first matching strategy or &#123;@code null&#125;. * @since 4.3 */ @SuppressWarnings(\"unchecked\") public &lt;T extends ContentNegotiationStrategy&gt; T getStrategy(Class&lt;T&gt; strategyType) &#123; for (ContentNegotiationStrategy strategy : getStrategies()) &#123; if (strategyType.isInstance(strategy)) &#123; return (T) strategy; &#125; &#125; return null; &#125; /** * Register more &#123;@code MediaTypeFileExtensionResolver&#125; instances in addition * to those detected at construction. * @param resolvers the resolvers to add */ public void addFileExtensionResolvers(MediaTypeFileExtensionResolver... resolvers) &#123; this.resolvers.addAll(Arrays.asList(resolvers)); &#125; @Override public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException &#123; // 处理请求的代码逻辑在这里 for (ContentNegotiationStrategy strategy : this.strategies) &#123; List&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request); if (mediaTypes.isEmpty() || mediaTypes.equals(MEDIA_TYPE_ALL)) &#123; continue; &#125; return mediaTypes; &#125; return Collections.emptyList(); &#125; @Override public List&lt;String&gt; resolveFileExtensions(MediaType mediaType) &#123; Set&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(); for (MediaTypeFileExtensionResolver resolver : this.resolvers) &#123; result.addAll(resolver.resolveFileExtensions(mediaType)); &#125; return new ArrayList&lt;String&gt;(result); &#125; /** * &#123;@inheritDoc&#125; * &lt;p&gt;At startup this method returns extensions explicitly registered with * either &#123;@link PathExtensionContentNegotiationStrategy&#125; or * &#123;@link ParameterContentNegotiationStrategy&#125;. At runtime if there is a * \"path extension\" strategy and its * &#123;@link PathExtensionContentNegotiationStrategy#setUseJaf(boolean) * useJaf&#125; property is set to \"true\", the list of extensions may * increase as file extensions are resolved via JAF and cached. */ @Override public List&lt;String&gt; getAllFileExtensions() &#123; Set&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(); for (MediaTypeFileExtensionResolver resolver : this.resolvers) &#123; result.addAll(resolver.getAllFileExtensions()); &#125; return new ArrayList&lt;String&gt;(result); &#125;&#125; 其中resolveMediaTypes方法即为处理逻辑方法，可以看到业务逻辑的实际处理逻辑在strategies中的各个strategy中。而WebMvcConfigurer类的configureContentNegotiation方法实际就是添加了一些配置用来改变产生ContentNegotiationManager类Bean时配置其strategies的行为，此方法的参数为ContentNegotiationConfigurer类型，通过查看ContentNegotiationConfigurer的源代码我们可以看其实际将配置参数传递给了成员变量factory，类型为ContentNegotiationManagerFactoryBean，所以实际最终产生ContentNegotiationManager的代码都在ContentNegotiationManagerFactoryBean里面，源代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304/* * Copyright 2002-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.web.accept;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Map.Entry;import java.util.Properties;import javax.servlet.ServletContext;import org.springframework.beans.factory.FactoryBean;import org.springframework.beans.factory.InitializingBean;import org.springframework.http.MediaType;import org.springframework.util.Assert;import org.springframework.util.CollectionUtils;import org.springframework.web.context.ServletContextAware;/** * Factory to create a &#123;@code ContentNegotiationManager&#125; and configure it with * one or more &#123;@link ContentNegotiationStrategy&#125; instances via simple setters. * The following table shows setters, resulting strategy instances, and if in * use by default: * * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;Property Setter&lt;/th&gt; * &lt;th&gt;Underlying Strategy&lt;/th&gt; * &lt;th&gt;Default Setting&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&#123;@link #setFavorPathExtension&#125;&lt;/td&gt; * &lt;td&gt;&#123;@link PathExtensionContentNegotiationStrategy Path Extension strategy&#125;&lt;/td&gt; * &lt;td&gt;On&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&#123;@link #setFavorParameter favorParameter&#125;&lt;/td&gt; * &lt;td&gt;&#123;@link ParameterContentNegotiationStrategy Parameter strategy&#125;&lt;/td&gt; * &lt;td&gt;Off&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&#123;@link #setIgnoreAcceptHeader ignoreAcceptHeader&#125;&lt;/td&gt; * &lt;td&gt;&#123;@link HeaderContentNegotiationStrategy Header strategy&#125;&lt;/td&gt; * &lt;td&gt;On&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&#123;@link #setDefaultContentType defaultContentType&#125;&lt;/td&gt; * &lt;td&gt;&#123;@link FixedContentNegotiationStrategy Fixed content strategy&#125;&lt;/td&gt; * &lt;td&gt;Not set&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&#123;@link #setDefaultContentTypeStrategy defaultContentTypeStrategy&#125;&lt;/td&gt; * &lt;td&gt;&#123;@link ContentNegotiationStrategy&#125;&lt;/td&gt; * &lt;td&gt;Not set&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; * * &lt;p&gt;The order in which strategies are configured is fixed. Setters may only * turn individual strategies on or off. If you need a custom order for any * reason simply instantiate &#123;@code ContentNegotiationManager&#125; directly. * * &lt;p&gt;For the path extension and parameter strategies you may explicitly add * &#123;@link #setMediaTypes MediaType mappings&#125;. This will be used to resolve path * extensions or a parameter value such as \"json\" to a media type such as * \"application/json\". * * &lt;p&gt;The path extension strategy will also use &#123;@link ServletContext#getMimeType&#125; * and the Java Activation framework (JAF), if available, to resolve a path * extension to a MediaType. You may &#123;@link #setUseJaf suppress&#125; the use of JAF. * * @author Rossen Stoyanchev * @since 3.2 */public class ContentNegotiationManagerFactoryBean implements FactoryBean&lt;ContentNegotiationManager&gt;, ServletContextAware, InitializingBean &#123; private boolean favorPathExtension = true; private boolean favorParameter = false; private boolean ignoreAcceptHeader = false; private Map&lt;String, MediaType&gt; mediaTypes = new HashMap&lt;String, MediaType&gt;(); private boolean ignoreUnknownPathExtensions = true; private Boolean useJaf; private String parameterName = \"format\"; private ContentNegotiationStrategy defaultNegotiationStrategy; private ContentNegotiationManager contentNegotiationManager; private ServletContext servletContext; /** * Whether the path extension in the URL path should be used to determine * the requested media type. * &lt;p&gt;By default this is set to &#123;@code true&#125; in which case a request * for &#123;@code /hotels.pdf&#125; will be interpreted as a request for * &#123;@code \"application/pdf\"&#125; regardless of the 'Accept' header. */ public void setFavorPathExtension(boolean favorPathExtension) &#123; this.favorPathExtension = favorPathExtension; &#125; /** * Add a mapping from a key, extracted from a path extension or a query * parameter, to a MediaType. This is required in order for the parameter * strategy to work. Any extensions explicitly registered here are also * whitelisted for the purpose of Reflected File Download attack detection * (see Spring Framework reference documentation for more details on RFD * attack protection). * &lt;p&gt;The path extension strategy will also try to use * &#123;@link ServletContext#getMimeType&#125; and JAF (if present) to resolve path * extensions. To change this behavior see the &#123;@link #useJaf&#125; property. * @param mediaTypes media type mappings * @see #addMediaType(String, MediaType) * @see #addMediaTypes(Map) */ public void setMediaTypes(Properties mediaTypes) &#123; if (!CollectionUtils.isEmpty(mediaTypes)) &#123; for (Entry&lt;Object, Object&gt; entry : mediaTypes.entrySet()) &#123; String extension = ((String)entry.getKey()).toLowerCase(Locale.ENGLISH); MediaType mediaType = MediaType.valueOf((String) entry.getValue()); this.mediaTypes.put(extension, mediaType); &#125; &#125; &#125; /** * An alternative to &#123;@link #setMediaTypes&#125; for use in Java code. * @see #setMediaTypes * @see #addMediaTypes */ public void addMediaType(String fileExtension, MediaType mediaType) &#123; this.mediaTypes.put(fileExtension, mediaType); &#125; /** * An alternative to &#123;@link #setMediaTypes&#125; for use in Java code. * @see #setMediaTypes * @see #addMediaType */ public void addMediaTypes(Map&lt;String, MediaType&gt; mediaTypes) &#123; if (mediaTypes != null) &#123; this.mediaTypes.putAll(mediaTypes); &#125; &#125; /** * Whether to ignore requests with path extension that cannot be resolved * to any media type. Setting this to &#123;@code false&#125; will result in an * &#123;@code HttpMediaTypeNotAcceptableException&#125; if there is no match. * &lt;p&gt;By default this is set to &#123;@code true&#125;. */ public void setIgnoreUnknownPathExtensions(boolean ignore) &#123; this.ignoreUnknownPathExtensions = ignore; &#125; /** * When &#123;@link #setFavorPathExtension favorPathExtension&#125; is set, this * property determines whether to allow use of JAF (Java Activation Framework) * to resolve a path extension to a specific MediaType. * &lt;p&gt;By default this is not set in which case * &#123;@code PathExtensionContentNegotiationStrategy&#125; will use JAF if available. */ public void setUseJaf(boolean useJaf) &#123; this.useJaf = useJaf; &#125; private boolean isUseJafTurnedOff() &#123; return (this.useJaf != null &amp;&amp; !this.useJaf); &#125; /** * Whether a request parameter (\"format\" by default) should be used to * determine the requested media type. For this option to work you must * register &#123;@link #setMediaTypes media type mappings&#125;. * &lt;p&gt;By default this is set to &#123;@code false&#125;. * @see #setParameterName */ public void setFavorParameter(boolean favorParameter) &#123; this.favorParameter = favorParameter; &#125; /** * Set the query parameter name to use when &#123;@link #setFavorParameter&#125; is on. * &lt;p&gt;The default parameter name is &#123;@code \"format\"&#125;. */ public void setParameterName(String parameterName) &#123; Assert.notNull(parameterName, \"parameterName is required\"); this.parameterName = parameterName; &#125; /** * Whether to disable checking the 'Accept' request header. * &lt;p&gt;By default this value is set to &#123;@code false&#125;. */ public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader) &#123; this.ignoreAcceptHeader = ignoreAcceptHeader; &#125; /** * Set the default content type to use when no content type is requested. * &lt;p&gt;By default this is not set. * @see #setDefaultContentTypeStrategy */ public void setDefaultContentType(MediaType contentType) &#123; this.defaultNegotiationStrategy = new FixedContentNegotiationStrategy(contentType); &#125; /** * Set a custom &#123;@link ContentNegotiationStrategy&#125; to use to determine * the content type to use when no content type is requested. * &lt;p&gt;By default this is not set. * @see #setDefaultContentType * @since 4.1.2 */ public void setDefaultContentTypeStrategy(ContentNegotiationStrategy strategy) &#123; this.defaultNegotiationStrategy = strategy; &#125; /** * Invoked by Spring to inject the ServletContext. */ @Override public void setServletContext(ServletContext servletContext) &#123; this.servletContext = servletContext; &#125; @Override public void afterPropertiesSet() &#123; List&lt;ContentNegotiationStrategy&gt; strategies = new ArrayList&lt;ContentNegotiationStrategy&gt;(); if (this.favorPathExtension) &#123; PathExtensionContentNegotiationStrategy strategy; if (this.servletContext != null &amp;&amp; !isUseJafTurnedOff()) &#123; strategy = new ServletPathExtensionContentNegotiationStrategy( this.servletContext, this.mediaTypes); &#125; else &#123; strategy = new PathExtensionContentNegotiationStrategy(this.mediaTypes); &#125; strategy.setIgnoreUnknownExtensions(this.ignoreUnknownPathExtensions); if (this.useJaf != null) &#123; strategy.setUseJaf(this.useJaf); &#125; strategies.add(strategy); &#125; if (this.favorParameter) &#123; ParameterContentNegotiationStrategy strategy = new ParameterContentNegotiationStrategy(this.mediaTypes); strategy.setParameterName(this.parameterName); strategies.add(strategy); &#125; if (!this.ignoreAcceptHeader) &#123; strategies.add(new HeaderContentNegotiationStrategy()); &#125; if (this.defaultNegotiationStrategy != null) &#123; strategies.add(this.defaultNegotiationStrategy); &#125; this.contentNegotiationManager = new ContentNegotiationManager(strategies); &#125; @Override public ContentNegotiationManager getObject() &#123; return this.contentNegotiationManager; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return ContentNegotiationManager.class; &#125; @Override public boolean isSingleton() &#123; return true; &#125;&#125; 从源代码可以看到产生contentNegotiationManager的代码逻辑在afterPropertiesSet方法中。至此在spring boot中通过EnableWebMvc和扩展WebMvcConfigurerAdapter配置contentNegotiation逻辑就梳理完成了。 Could not parse header json？在项目实际运行的时候，spring mvc框架报错了，查看异常栈发现是在ContentNegotiationStrategy的一个实现类HeaderContentNegotiationStrategy的resolveMediaTypes方法中报错。源代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * Copyright 2002-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.web.accept;import java.util.Arrays;import java.util.Collections;import java.util.List;import org.springframework.http.HttpHeaders;import org.springframework.http.InvalidMediaTypeException;import org.springframework.http.MediaType;import org.springframework.web.HttpMediaTypeNotAcceptableException;import org.springframework.web.context.request.NativeWebRequest;/** * A &#123;@code ContentNegotiationStrategy&#125; that checks the 'Accept' request header. * * @author Rossen Stoyanchev * @author Juergen Hoeller * @since 3.2 */public class HeaderContentNegotiationStrategy implements ContentNegotiationStrategy &#123; /** * &#123;@inheritDoc&#125; * @throws HttpMediaTypeNotAcceptableException if the 'Accept' header cannot be parsed */ @Override public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException &#123; String[] headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT); if (headerValueArray == null) &#123; return Collections.&lt;MediaType&gt;emptyList(); &#125; List&lt;String&gt; headerValues = Arrays.asList(headerValueArray); try &#123; List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(headerValues); MediaType.sortBySpecificityAndQuality(mediaTypes); return mediaTypes; &#125; catch (InvalidMediaTypeException ex) &#123; throw new HttpMediaTypeNotAcceptableException( \"Could not parse 'Accept' header \" + headerValues + \": \" + ex.getMessage()); &#125; &#125;&#125; 从源代码中我们可以看到，此类是通过请求中的Accept头部来判断客户端请求是要获取什么类型的数据，而从异常栈中可以看到异常只可能来自于MediaType.parseMediaType这一行，往下追踪源代码，发现异常来自于MimeTypeUtils类,代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static MimeType parseMimeType(String mimeType) &#123; if(!StringUtils.hasLength(mimeType)) &#123; throw new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\"); &#125; else &#123; int index = mimeType.indexOf(59); String fullType = (index &gt;= 0?mimeType.substring(0, index):mimeType).trim(); if(fullType.length() == 0) &#123; throw new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\"); &#125; else &#123; if(\"*\".equals(fullType)) &#123; fullType = \"*/*\"; &#125; int subIndex = fullType.indexOf(47); if(subIndex == -1) &#123; throw new InvalidMimeTypeException(mimeType, \"does not contain '/'\"); &#125; else if(subIndex == fullType.length() - 1) &#123; throw new InvalidMimeTypeException(mimeType, \"does not contain subtype after '/'\"); &#125; else &#123; String type = fullType.substring(0, subIndex); String subtype = fullType.substring(subIndex + 1, fullType.length()); if(\"*\".equals(type) &amp;&amp; !\"*\".equals(subtype)) &#123; throw new InvalidMimeTypeException(mimeType, \"wildcard type is legal only in '*/*' (all mime types)\"); &#125; else &#123; LinkedHashMap parameters = null; int nextIndex; do &#123; nextIndex = index + 1; for(boolean quoted = false; nextIndex &lt; mimeType.length(); ++nextIndex) &#123; char ch = mimeType.charAt(nextIndex); if(ch == 59) &#123; if(!quoted) &#123; break; &#125; &#125; else if(ch == 34) &#123; quoted = !quoted; &#125; &#125; String parameter = mimeType.substring(index + 1, nextIndex).trim(); if(parameter.length() &gt; 0) &#123; if(parameters == null) &#123; parameters = new LinkedHashMap(4); &#125; int eqIndex = parameter.indexOf(61); if(eqIndex &gt;= 0) &#123; String attribute = parameter.substring(0, eqIndex); String value = parameter.substring(eqIndex + 1, parameter.length()); parameters.put(attribute, value); &#125; &#125; index = nextIndex; &#125; while(nextIndex &lt; mimeType.length()); try &#123; return new MimeType(type, subtype, parameters); &#125; catch (UnsupportedCharsetException var13) &#123; throw new InvalidMimeTypeException(mimeType, \"unsupported charset '\" + var13.getCharsetName() + \"'\"); &#125; catch (IllegalArgumentException var14) &#123; throw new InvalidMimeTypeException(mimeType, var14.getMessage()); &#125; &#125; &#125; &#125; &#125; &#125; 至此我们发现，原来是因为Accept头部json没有包含/。 How To Fix？通过上面的分析我们发现，问题的源头在于contentNegotiationManager的strategies中包含了HeaderContentNegotiationStrategy，我们要做的就是配置ContentNegotiationManagerFactoryBean，使其在产生contentNegotiationManager时不要配置HeaderContentNegotiationStrategy，查看ContentNegotiationManagerFactoryBean源代码可以看到，通过配置其ignoreAcceptHeader变量为true即可，这个配置项也可通过WebMvcConfigurerAdapter的configureContentNegotiation进行间接配置，代码如下： 12345@Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123; configurer.ignoreAcceptHeader(true).defaultContentType( MediaType.APPLICATION_JSON); &#125;","link":"","categories":[],"tags":[]},{"title":"HTTP-METHOD","date":"2017-02-04T09:26:49.000Z","path":"2017/02/04/HTTP-METHOD/","text":"HTTP请求方法介绍HTTP/1.1协议中定义了8中请求方法，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。 GETGET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应该用于会产生副作用的非幂等操作中。 HEADHEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分。使用HEAD方法可以不传输全部内容，就能获取服务器响应头信息。HEAD方法常被用于客户端查看服务器性能。 POSTPOST请求会向指定资源提交数据，请求服务器进行处理，如表单提交、文件上传等，请求数据会被包含在请求主体中。POST方法是非幂等的，因为这个请求会创建新的资源或者修改现有的资源。 DELETEDELETE请求用于请求服务器删除请求URI标识的资源。DELETE请求后制定资源会被删除，DELETE方法也是幂等的。 CONNECTCONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密HTTP代理服务器的通信。 OPTIONSOPTIONS请求与HEAD类似，一般也是用于客户端查看服务器性能。这个方法会请求服务器返回该资源所支持的所有HTTP请求方法。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有指定资源的访问权限。 TRACETRACE请求服务器回显其收到的请求信息，改方法主要用于HTTP请求的测试和诊断。","link":"","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://buptubuntu.github.io/tags/HTTP/"}]},{"title":"High-Performance-MYWQL-Chapter-Four","date":"2017-02-02T01:18:25.000Z","path":"2017/02/02/High-Performance-MYSQL-Chapter-Four/","text":"选择优化的数据类型 更小的通常更好 尽量避免NULL很多表都包含可为NULL（空值）的列，即使应用程序并不需要保存NULL也是如此。通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。如果查询中包含可为NULL的列，对于MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更加复杂。InnoDB使用单独的位（bit）存储NULL值，所以对于稀疏数据有很好的空间效率。但这一点不适用于MyISAM。 很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样，允许的精度不同，或者需要的物理空间不同。相同大类型的不同子类型数据有时也有一些特殊的行为和属性。例如DATETIME和TIMESTAMP列都可以存储相同类型的数据：时间和日期，精确到秒。然而TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。另一方面，TIMESTAMP允许的时间范围要小得多，有时候它的特殊能力会成为障碍。 MySQL为了兼容性支持很多别名，例如INTEGER、BOOL以及NUMERIC。它们都只是别名。 实数类型MySQL可以为整数类型指定宽度，例如INT(11)，对于大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL的一些交互工具（例如MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT（1）和INT（20）是相同的。 有多种方法可以指定浮点列所需要的精度，这回使得MySQL悄悄选择不同的数据类型，或者在存储时对值进行取舍。这些精度定义时非标准的，所以我们建议只指定数据类型，不指定精度。 因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAL——例如存储财务数据。但在数据量比较大的时候，可以考虑使用BIGINT代替DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。 字符串类型 VARCHARVARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型，它比定长类型更节省空间。有一种情况例外，如果MySQL表使用ROW_FORMAT=FIXED创建的话，么一行都会使用定长存储，这会很浪费空间。 CHARCHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。CHAR适合存储很短的字符串，或者所有值都接近同一个长度。数据如何存储取决于存储引擎，并非所有的存储引擎都会按照相同的方式处理，并非所有的存储引擎都会按照相同的方式处理定长和变长字符串。Memory引擎只支持定长的行，即使有变长字段也会根据最大长度分配最大空间。不过，填充和截取空格的行为在不同存储引擎都是一样的，因为这是在MySQL服务器层进行处理的。 慷慨是不明智的使用VARCHAR(5)和VARCHAR(200)存储‘hello’的空间开销是一样的。那么使用更短的列有什么优势吗？事实证明有很大的优势。更长的列消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序和操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。 BLOB和TEXT类型BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。与其他类型不同，MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储指针，然后在外部存储区域存储实际的值。MySQL对BLOB和TEXT列进行排序和其他类型是不同的：它只对每个列的最前max_sort_length字节而不是整个字符串做排序。 使用枚举(ENUM)代替字符串类型。 日期和时间类型TIMESTAMP列默认为NOT NULL，这也和其他的数据类型不一样。 位数据类型MySQL有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。 选择标识符 整数类型整数通常是标识列最好的选择，因为它们很快并且可以使用AUTO_INCREMENT。 ENUM和SET类型对于标识列来说ENUM和SET类型通常是一个糟糕的选择。ENUM和SET列适合存储固定信息，例如有序的状态、产品类型、人的性别。 字符串类型如果可能，应该尽量避免使用字符串作为标识列，因为它们很消耗空间，并且通常比数字类型慢。对于完全“随机”的字符串也需要多加注意，例如MD5(),SHA1()或者UUID()产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢： 因为插入值会随机地写到索引的不同位置，所以使得INSERT语句更慢。这会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。 SELECT语句会变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方 随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的访问局部习惯原理失效。如果整个数据集都一样的“热”，那么缓存任何一部分特定数据到内存都没有好处；如果工作集比内存大，缓存将会有很多刷新和不命中。 如果存储UUID值，则应该移除“-”符号；更好的做法是，用UNHEX()函数转换UUID值为16字节的数字，并且存储在一个BINARY(16)列中。检索时可以通过HEX()函数来格式化为十六进制格式。 当心自动生成的schema对象关系映射(ORM)系统(以及使用它们的“框架”)是另一种常见的性能噩梦。一些ORM系统会存储任意类型的数据到任意类型的后端数据存储中，这通常意味着其没有设计使用更优的数据类型来存储。有时会为每个对象的每个属性使用单独的行，甚至使用基于时间戳的版本控制，导致单个属性会有多个版本存在。 这种设计对开发者很有吸引力，因为这使得他们可以用面向对象的方式工作，不需要考虑数据是怎么存储的。然而，“对开发者隐藏其复杂性”的应用通常不能很好地扩展。建议在用性能交换开发人员的效率之前仔细考虑，并且总是在真实大小的数据集上做测试，这样就不会太晚才发现性能问题。 MySQL schema设计中的陷阱 太多的列当我们研究一个CPU占用非常高的案例时，发现客户使用了非常宽的表，然而只有一小部分列会实际用到，这时转换的代价就非常高。如果计划使用数千个字段，必须意识到服务器的性能运行特征会有一些不同。 太多的关联一个初略的经验法则，如果希望查询执行得快速并且并发性好，单个查询最好在12个表以内做关联。 非此发明(Not Invent Here)的NULL处理NULL确实不容易，但有时候会比它的替代方案更好。 范式和反范式对于任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。在范式化数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化数据库中，信息是冗余的，可能存储在多个地方。 范式的优点和缺点当为性能问题而寻求帮助时，经常会被建议对schema进行范式化设计，尤其是写密集的场景，这通常是个好建议。范式化通常能够带来好处： 范式化的更新操作通常比反范式化要快 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。 范式化设计的schema的缺点是通常需要关联。稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。这不但代价昂贵，也可能使一些索引策略无效。例如，范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引。 更快地读，更慢的写为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧：虽然写操作变得更慢了，但更显著提高了读操作的性能。然而，写操作变慢并不是读操作变得更快所付出的唯一代价，还可能同时增加了读操作和写操作的开发难度。","link":"","categories":[],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://buptubuntu.github.io/tags/MySql/"}]},{"title":"High-Performance-MYSQL-Chapter-Two","date":"2017-01-25T08:30:29.000Z","path":"2017/01/25/High-Performance-MYSQL-Chapter-Two/","text":"性能优化简介很多人对此很迷茫。加入你认为性能优化是降低CPU利用率，那么可以减少对资源的使用。但是这是一个陷阱，资源是用力啊消耗并用来工作的，所以有时候消耗更多的资源能够加快查询速度。CPU利用率只是一种现象，而不是很好的可度量的目标。 如果目标是降低响应时间，那么就需要理解为什么服务器执行查询需要这么多时间，然后减少或消除那些对获得查询结果来说不必要的工作。也就是说，要搞清楚时间花在哪里。这就引申出第二个原则：无法测量就无法有效优化。所以第一步应该测量时间花在什么地方。 测量是一项很有挑战性的工作，并且分析结果也同样有挑战性，测出时间花在哪里，和知道为什么花在那里，是两码事。 完成一项任务所需要的时间可以分为两部分：执行时间和等待时间。如果要优化任务的执行时间，最好的办法是通过测量定位不同的子任务花费的时间，然后优化去掉一些子任务、降低子任务的执行频率或者提升子任务的效率。而优化任务的等待时间则相对要复杂一些，因为等待有可能是其他系统间接影响导致。 通过性能剖析进行优化性能剖析一般有两个步骤：测量任务所花费的时间，然后对结果进行统计和排序，将重要的任务排到前面。 值得优化的查询如果优化的成本大于收益，就应当停止优化。","link":"","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://buptubuntu.github.io/tags/MYSQL/"}]},{"title":"High Performance MYSQL Chapter One","date":"2017-01-08T11:28:06.000Z","path":"2017/01/08/High-Performance-MYSQL-Chapter-One/","text":"连接管理和安全性每个客户端连接都会在服务器进程中有一个对应的线程，这个连接的查询只会在这个单独的线程中执行。服务器会负责缓存线程，因此不需要为每个新建的连接创建或销毁线程。 优化和执行优化器并不关心表使用的是什么存储引擎，但存储引擎对优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。 锁粒度一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量值锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据偏进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。 为时加锁也需要消耗资源。所的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。 所谓的锁策略，就是在所的开销和数据的安全性之间寻求平衡，这种平和当然也会影响到性能。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加行级锁，并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能地提供更好的性能。 而MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时却会失去对另外一些应用场景的良好支持。好在MySQL支持多个存储引擎的架构，所以不需要单一的通用解决方案。 表锁表锁是MySQL中最基本的锁策略，并且是开销最小的策略。在特定的场景中，表锁也可能有良好的性能。例如，READ LOCAL表锁支持某些类型的并发写操作。尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。 行级锁行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。 事务就像锁粒度的升级会增加系统开销一样，事务处理过程汇总的额外的安全性，也会需要数据库系统做更多的额外工作。一个实现了ACID的数据库，相比没有实现ACID的数据库，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。这正是MySQL的存储引擎可以发挥优势的地方。用户可以根据业务是否需要食物处理，来选择合适的存储引擎。对于一些不需要事务的查询类应用，选择一个非事务类型的存储引擎，可以获得更高的性能。即使存储引擎不支持事务，也可以通过LOCK TABLES语句为应用提供一定程度的保护，这些选择用户可以自主决定。 隔离级别在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在是屋内和事物间是可见的，哪些是不可见的。较低界别的隔离通常可以执行更高的并发，系统的开销也更低。 READ UNCOMMITTED（未提交读）在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他级别好太多，但却缺乏其他级别的很多好处，除非真的有必要的理由，在实际应用中一般很少使用。 READ COMMITTED（提交读）大多数数据库系统的默认隔离级别都是READ COMMITTED（MySQL不是）。一个事务从开始知道提交之前，所做的任何修改对其他事务都是不可见的。这个级别有的时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。 REPEATABLE READ（可重复读）REPEATABLE READ解决了脏读的问题。改级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。所谓幻读，值得是当某个事务在读取某个范围的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和XtraDB存储引擎通过多版本并发控制解决了幻读的问题。 SERIALIZABLE（可串行化）SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读问题。SERIALIZABLE会在读取的每一行数据上都加锁，所以额能导致大量的超时和锁争用的问题。 死锁死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务性的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。 事务日志事务日志课帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把改修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回磁盘。 MySQL中的事务MySQL中提供了两种事务型的存储引擎：InnoDB和NDB Cluster。 自动提交（AUTOCOMMIT）MySQL偶人采用自动提交模式。也就是说，如果不是显式地开始一个事务，则每个查询都会被当做一个事务执行提交操作。 在事务中混合使用存储引擎MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。如果正常提交，不会有什么问题；但是如果事务要回滚，非事务型表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。 隐式和显式锁定经常可以发现，应用已经将表从MyISAM换到InnoDB，但是还是使用LOCK TABLES语句。这没有必要而且影响性能，InnoDB的行级锁工作得更好 自动提交存储引擎在文件系统中，MySQL将每个数据库（也可以称之为schema）保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件中保存该表的定义。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在MySQL服务层统一处理的。 可以使用SHOW TABLE STATUS命令显示表的相关信息。例如：SHOW TABLE STATUA LIKE ‘user’ InnoDB存储引擎InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况是正常提交的，很少会被回滚。 InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁策略防止幻读的出现，间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定。 InnoDB表是基于聚簇索引建立的，对主键查询有很高的性能。不过它的二级索引中必须包含主键列。InnoDB的存储格式是平台独立的，也就是说可以将数据和索引文件从Intel平台复制到PowerPC或者Sun SPARC平台。 基准测试的策略测试何种指标吞吐量吞吐量指的是单位时间内处的事务处理数。这类基准测试主要针对在线事务处理(OLTP)的吞吐量，非常适用于多用户的交互式应用。 响应时间或者延迟这个指标用于测试任务所需的整体时间。包括平均响应时间、最小响应时间、最大响应时间和所占百分比，最大响应时间通常意义不大。通常可以使用百分比响应时间来代替最大响应时间。例如，如果95%的响应时间是5ms，则表示任务在95%的响应时间都是5ms。 并发性一个设计良好的应用，同时可以打开成百上千个MySQL数据库服务器连接，但可能同时只有少数连接在执行查询。所以说，一个Web站点“同时有50000个用户”访问，却可能只有10-15个并发请求到MySQL数据库。并发性的测量完全不同于响应时间和吞吐量。它不像是一个结果，而更像是设置基准测试的一种属性。并发性测试通常不是为了测试应用能达到的并发度，而是为了测试应用在不同并发下的性能。当然数据库的并发性还是需要测量的。可以通过sysbench指定32、64或128个线程的测试，然后在测试期间记录MySQL数据库的Treads_running状态值。 归根结底，应该测试那些对用户来说最重要的指标。因此应该尽可能地去收集一些需求，比如，什么样的响应时间是可以接受的，期待多少的并发性，等等。然后基于这些需求来设计基准测试，避免目光短浅只关注部分指标，而忽略其他指标。 MySQL存储引擎 Memory引擎Memory表支持Hash索引，因此查找操作非常快。虽然Memory表的速度非常快，但还是无法取代传统的基于磁盘的表。Memory表是表级锁，因此并发写入的性能较低。它不支持BLOB或TEXT类型的列，并且每行的长度是固定的，所以即使指定了VARCHAR列，实际存储时也会转换为CHAR。 如果MySQL在执行查询的过程中需要使用临时表来保存中间结果，内部使用的临时表就是Memory表。如果中间结果太大超出了Memory表的限制，或者含有BLOB或TEXT字段，则临时表会转换成MyISAM表。","link":"","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://buptubuntu.github.io/tags/MYSQL/"}]},{"title":"Spring Best Practice","date":"2017-01-02T04:19:26.000Z","path":"2017/01/02/Spring-Best-Practice/","text":"Spring 最佳实践编程语言或者是框架的实现往往允许我们通过多种方式去解决我们现实业务中遇到的问题，往往对于同一个问题我们不同的人会使用不同的方法去解决问题，但是从前辈的经验或者说从系统的可扩展性、后续维护成本的角度来说，一些沉淀下来的方式相比于其他同样可以解决现在业务问题的方式才是最佳的实践方式。 INTERFACES AND SPRING1If,after reading the last couple of paragraphs,you feel that I have a strong bias toward hiding the persistence layer hebind interfaces,then I&apos;m happy I was able to get that point acrss. I believe that interfaces are key to writing loosely coupled code and that they should be used at all layers of an application, not just at the data-access layer.That said, it&apos;s also important to note that though Spring encourages the use of interfaces, Spring dosen&apos;t require them--you&apos;re welcome to use Spring to write a bean(repository or otherwise) directly into a property of another bean without an interface between them. 上面的话摘自Spring in Action, Spring框架允许我们在IOC时注入接口（框架自动匹配实现了接口的具体类的bean）或者直接注入具体类型的bean, 不可否认, 我们可以在具体的实现时可以不用定义接口，直接定义具体的实现类来达到我们的目的，但是这样的系统内部往往耦合性比较高，不利于后续的扩展和维护，所以Spring鼓励框架的使用者通过定义接口来约定行为集合，然后通过具体类实现接口，已达到松耦合的目的。 SPRING’S PERSISTENCE PLATFORM-AGNOSTIC EXCEPTIONS123456789Spring JDBC provides hierarchy of data-access exceptions that solve both problems. In constrast to JDBC, Spring provides several data-access exceptions, each descriptive of the problem for which they&apos;re thrown.Even though Spring&apos;s exception hierarchy is far richer than JDBC&apos;s simple SQL-Exception it isn&apos;t associated with any particular persistence solution. This means you can count on Spring to throw a consistent set of exceptions, regardlesss of which persistence provider you choose. This helps to keep your persistence choice confined to the data-access layer.To take advantage of Spring&apos;s data-access esceptions, you must use one of Spring&apos;s supported data-access templates.(Design pattern: template method pattern)Spring separates the fixed and variable parts of the data-access process into two distinct classes: templates and callbacks. Templates manage the fixed part of the process, whereas your custom data-access code is handled in callbacks.JDBC is the most basic way to work with ralational data in Java. But as defined in the specification,JDBC can be somewhat unwieldy. Spring takes much of the pain out of working with JDBC, eliminating boilerpalte code and simplifying JDBC exception handling, leaving you little more to deal with than writing the SQL that should be performed.","link":"","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://buptubuntu.github.io/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"https://buptubuntu.github.io/tags/Java/"},{"name":"Best Practice","slug":"Best-Practice","permalink":"https://buptubuntu.github.io/tags/Best-Practice/"}]},{"title":"Spring MVC Exception Handling","date":"2016-12-29T10:35:57.000Z","path":"2016/12/29/Spring-MVC-Exception-Handling/","text":"在Spring MVC中可以从三个角度对异常进行处理： 对特定类型的异常进行处理 对特定类型的Controller类进行异常处理 全局异常处理 对特定类型的异常进行处理对于特定类型的异常，我们可以通过给异常类添加ResponseStatus注解，在Controller类抛出此类异常时Spring MVC框架会自动将指定的相应码写入到请求的响应中。 比如如果有一个异常表示没有查询到订单： 1234@ResponseStatus(value=HttpStatus.NOT_FOUND, reason=\"No such Order\") // 404 public class OrderNotFoundException extends RuntimeException &#123; // ... &#125; 在某个Controller中抛出了该异常： 123456789@RequestMapping(value=\"/orders/&#123;id&#125;\", method=GET) public String showOrder(@PathVariable(\"id\") long id, Model model) &#123; Order order = orderRepository.findOrderById(id); if (order == null) throw new OrderNotFoundException(id); model.addAttribute(order); return \"orderDetail\"; &#125; 那么当请求的订单ID不存的时候，请求的响应验证码就是404 单个Controller类中的异常处理在单个Controller类中，我们可以单独定义一个方法，并使用ExceptionHandler注解标注该方法，那么此Contrller类中如果有请求抛出特定异常时将由改方法来处理。代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940@Controllerpublic class ExceptionHandlingController &#123; // @RequestHandler methods ... // Exception handling methods // Convert a predefined exception to an HTTP Status code @ResponseStatus(value=HttpStatus.CONFLICT, reason=\"Data integrity violation\") // 409 @ExceptionHandler(DataIntegrityViolationException.class) public void conflict() &#123; // Nothing to do &#125; // Specify name of a specific view that will be used to display the error: @ExceptionHandler(&#123;SQLException.class,DataAccessException.class&#125;) public String databaseError() &#123; // Nothing to do. Returns the logical view name of an error page, passed // to the view-resolver(s) in usual way. // Note that the exception is NOT available to this view (it is not added // to the model) but see \"Extending ExceptionHandlerExceptionResolver\" // below. return \"databaseError\"; &#125; // Total control - setup a model and return the view name yourself. Or // consider subclassing ExceptionHandlerExceptionResolver (see below). @ExceptionHandler(Exception.class) public ModelAndView handleError(HttpServletRequest req, Exception ex) &#123; logger.error(\"Request: \" + req.getRequestURL() + \" raised \" + ex); ModelAndView mav = new ModelAndView(); mav.addObject(\"exception\", ex); mav.addObject(\"url\", req.getRequestURL()); mav.setViewName(\"error\"); return mav; &#125;&#125; 全局异常处理在很多情况下，我们可能想要对所有Controller抛出的异常做统一的处理，在这种情况下，我们可以充分利用Spring提供的切面功能，在Spring MVC中我们可以通过简单的ControllerAdvice注解达到目的。代码示例如下：12345678@ControllerAdviceclass GlobalControllerExceptionHandler &#123; @ResponseStatus(HttpStatus.CONFLICT) // 409 @ExceptionHandler(DataIntegrityViolationException.class) public void handleConflict() &#123; // Nothing to do &#125;&#125; 通过上面的代码，所有Controller抛出的DataIntegrityViolationException异常都讲集中进行处理。","link":"","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"https://buptubuntu.github.io/tags/Spring-MVC/"},{"name":"Exception Handling","slug":"Exception-Handling","permalink":"https://buptubuntu.github.io/tags/Exception-Handling/"}]}]