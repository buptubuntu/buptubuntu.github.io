[{"title":"High Performance MYSQL Chapter One","date":"2017-01-08T11:28:06.000Z","path":"2017/01/08/High-Performance-MYSQL/","text":"连接管理和安全性每个客户端连接都会在服务器进程中有一个对应的线程，这个连接的查询只会在这个单独的线程中执行。服务器会负责缓存线程，因此不需要为每个新建的连接创建或销毁线程。 优化和执行优化器并不关心表使用的是什么存储引擎，但存储引擎对优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。 锁粒度一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量值锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据偏进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。 为时加锁也需要消耗资源。所的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。 所谓的锁策略，就是在所的开销和数据的安全性之间寻求平衡，这种平和当然也会影响到性能。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加行级锁，并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能地提供更好的性能。 而MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时却会失去对另外一些应用场景的良好支持。好在MySQL支持多个存储引擎的架构，所以不需要单一的通用解决方案。 表锁表锁是MySQL中最基本的锁策略，并且是开销最小的策略。在特定的场景中，表锁也可能有良好的性能。例如，READ LOCAL表锁支持某些类型的并发写操作。尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。 行级锁行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。 事务就像锁粒度的升级会增加系统开销一样，事务处理过程汇总的额外的安全性，也会需要数据库系统做更多的额外工作。一个实现了ACID的数据库，相比没有实现ACID的数据库，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。这正是MySQL的存储引擎可以发挥优势的地方。用户可以根据业务是否需要食物处理，来选择合适的存储引擎。对于一些不需要事务的查询类应用，选择一个非事务类型的存储引擎，可以获得更高的性能。即使存储引擎不支持事务，也可以通过LOCK TABLES语句为应用提供一定程度的保护，这些选择用户可以自主决定。 隔离级别在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在是屋内和事物间是可见的，哪些是不可见的。较低界别的隔离通常可以执行更高的并发，系统的开销也更低。 READ UNCOMMITTED（未提交读）在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他级别好太多，但却缺乏其他级别的很多好处，除非真的有必要的理由，在实际应用中一般很少使用。 READ COMMITTED（提交读）大多数数据库系统的默认隔离级别都是READ COMMITTED（MySQL不是）。一个事务从开始知道提交之前，所做的任何修改对其他事务都是不可见的。这个级别有的时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。 REPEATABLE READ（可重复读）REPEATABLE READ解决了脏读的问题。改级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。所谓幻读，值得是当某个事务在读取某个范围的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和XtraDB存储引擎通过多版本并发控制解决了幻读的问题。 SERIALIZABLE（可串行化）SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读问题。SERIALIZABLE会在读取的每一行数据上都加锁，所以额能导致大量的超时和锁争用的问题。 死锁死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务性的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。 事务日志事务日志课帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把改修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回磁盘。 MySQL中的事务MySQL中提供了两种事务型的存储引擎：InnoDB和NDB Cluster。 自动提交（AUTOCOMMIT）MySQL偶人采用自动提交模式。也就是说，如果不是显式地开始一个事务，则每个查询都会被当做一个事务执行提交操作。 在事务中混合使用存储引擎MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。如果正常提交，不会有什么问题；但是如果事务要回滚，非事务型表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。 隐式和显式锁定经常可以发现，应用已经将表从MyISAM换到InnoDB，但是还是使用LOCK TABLES语句。这没有必要而且影响性能，InnoDB的行级锁工作得更好 自动提交","link":"","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://buptubuntu.github.io/tags/MYSQL/"}]},{"title":"Spring Best Practice","date":"2017-01-02T04:19:26.000Z","path":"2017/01/02/Spring-Best-Practice/","text":"Spring 最佳实践编程语言或者是框架的实现往往允许我们通过多种方式去解决我们现实业务中遇到的问题，往往对于同一个问题我们不同的人会使用不同的方法去解决问题，但是从前辈的经验或者说从系统的可扩展性、后续维护成本的角度来说，一些沉淀下来的方式相比于其他同样可以解决现在业务问题的方式才是最佳的实践方式。 INTERFACES AND SPRING1If,after reading the last couple of paragraphs,you feel that I have a strong bias toward hiding the persistence layer hebind interfaces,then I&apos;m happy I was able to get that point acrss. I believe that interfaces are key to writing loosely coupled code and that they should be used at all layers of an application, not just at the data-access layer.That said, it&apos;s also important to note that though Spring encourages the use of interfaces, Spring dosen&apos;t require them--you&apos;re welcome to use Spring to write a bean(repository or otherwise) directly into a property of another bean without an interface between them. 上面的话摘自Spring in Action, Spring框架允许我们在IOC时注入接口（框架自动匹配实现了接口的具体类的bean）或者直接注入具体类型的bean, 不可否认, 我们可以在具体的实现时可以不用定义接口，直接定义具体的实现类来达到我们的目的，但是这样的系统内部往往耦合性比较高，不利于后续的扩展和维护，所以Spring鼓励框架的使用者通过定义接口来约定行为集合，然后通过具体类实现接口，已达到松耦合的目的。 SPRING’S PERSISTENCE PLATFORM-AGNOSTIC EXCEPTIONS123456789Spring JDBC provides hierarchy of data-access exceptions that solve both problems. In constrast to JDBC, Spring provides several data-access exceptions, each descriptive of the problem for which they&apos;re thrown.Even though Spring&apos;s exception hierarchy is far richer than JDBC&apos;s simple SQL-Exception it isn&apos;t associated with any particular persistence solution. This means you can count on Spring to throw a consistent set of exceptions, regardlesss of which persistence provider you choose. This helps to keep your persistence choice confined to the data-access layer.To take advantage of Spring&apos;s data-access esceptions, you must use one of Spring&apos;s supported data-access templates.(Design pattern: template method pattern)Spring separates the fixed and variable parts of the data-access process into two distinct classes: templates and callbacks. Templates manage the fixed part of the process, whereas your custom data-access code is handled in callbacks.JDBC is the most basic way to work with ralational data in Java. But as defined in the specification,JDBC can be somewhat unwieldy. Spring takes much of the pain out of working with JDBC, eliminating boilerpalte code and simplifying JDBC exception handling, leaving you little more to deal with than writing the SQL that should be performed.","link":"","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://buptubuntu.github.io/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"https://buptubuntu.github.io/tags/Java/"},{"name":"Best Practice","slug":"Best-Practice","permalink":"https://buptubuntu.github.io/tags/Best-Practice/"}]},{"title":"Spring MVC Exception Handling","date":"2016-12-29T10:35:57.000Z","path":"2016/12/29/Spring-MVC-Exception-Handling/","text":"在Spring MVC中可以从三个角度对异常进行处理： 对特定类型的异常进行处理 对特定类型的Controller类进行异常处理 全局异常处理 对特定类型的异常进行处理对于特定类型的异常，我们可以通过给异常类添加ResponseStatus注解，在Controller类抛出此类异常时Spring MVC框架会自动将指定的相应码写入到请求的响应中。 比如如果有一个异常表示没有查询到订单： 1234@ResponseStatus(value=HttpStatus.NOT_FOUND, reason=\"No such Order\") // 404 public class OrderNotFoundException extends RuntimeException &#123; // ... &#125; 在某个Controller中抛出了该异常： 123456789@RequestMapping(value=\"/orders/&#123;id&#125;\", method=GET) public String showOrder(@PathVariable(\"id\") long id, Model model) &#123; Order order = orderRepository.findOrderById(id); if (order == null) throw new OrderNotFoundException(id); model.addAttribute(order); return \"orderDetail\"; &#125; 那么当请求的订单ID不存的时候，请求的响应验证码就是404 单个Controller类中的异常处理在单个Controller类中，我们可以单独定义一个方法，并使用ExceptionHandler注解标注该方法，那么此Contrller类中如果有请求抛出特定异常时将由改方法来处理。代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940@Controllerpublic class ExceptionHandlingController &#123; // @RequestHandler methods ... // Exception handling methods // Convert a predefined exception to an HTTP Status code @ResponseStatus(value=HttpStatus.CONFLICT, reason=\"Data integrity violation\") // 409 @ExceptionHandler(DataIntegrityViolationException.class) public void conflict() &#123; // Nothing to do &#125; // Specify name of a specific view that will be used to display the error: @ExceptionHandler(&#123;SQLException.class,DataAccessException.class&#125;) public String databaseError() &#123; // Nothing to do. Returns the logical view name of an error page, passed // to the view-resolver(s) in usual way. // Note that the exception is NOT available to this view (it is not added // to the model) but see \"Extending ExceptionHandlerExceptionResolver\" // below. return \"databaseError\"; &#125; // Total control - setup a model and return the view name yourself. Or // consider subclassing ExceptionHandlerExceptionResolver (see below). @ExceptionHandler(Exception.class) public ModelAndView handleError(HttpServletRequest req, Exception ex) &#123; logger.error(\"Request: \" + req.getRequestURL() + \" raised \" + ex); ModelAndView mav = new ModelAndView(); mav.addObject(\"exception\", ex); mav.addObject(\"url\", req.getRequestURL()); mav.setViewName(\"error\"); return mav; &#125;&#125; 全局异常处理在很多情况下，我们可能想要对所有Controller抛出的异常做统一的处理，在这种情况下，我们可以充分利用Spring提供的切面功能，在Spring MVC中我们可以通过简单的ControllerAdvice注解达到目的。代码示例如下：12345678@ControllerAdviceclass GlobalControllerExceptionHandler &#123; @ResponseStatus(HttpStatus.CONFLICT) // 409 @ExceptionHandler(DataIntegrityViolationException.class) public void handleConflict() &#123; // Nothing to do &#125;&#125; 通过上面的代码，所有Controller抛出的DataIntegrityViolationException异常都讲集中进行处理。","link":"","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"https://buptubuntu.github.io/tags/Spring-MVC/"},{"name":"Exception Handling","slug":"Exception-Handling","permalink":"https://buptubuntu.github.io/tags/Exception-Handling/"}]}]